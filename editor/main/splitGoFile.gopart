func splitGoFile(filename string) {
	// Read the Go file
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Fatalf("Error reading file %s: %v", filename, err)
	}

	// Parse the Go file
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, content, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error parsing file %s: %v", filename, err)
	}

	// Create the editor directory
	baseDir := filepath.Join("editor", strings.TrimSuffix(filename, ".go"))
	err = os.MkdirAll(baseDir, 0755)
	if err != nil {
		log.Fatalf("Error creating directory %s: %v", baseDir, err)
	}

	// Extract package declaration, imports, and //go:embed directives
	var packageAndImports strings.Builder
	packageAndImports.WriteString(fmt.Sprintf("package %s\n\n", f.Name.Name))

	// Handle //go:embed directives
	for _, cg := range f.Comments {
		for _, c := range cg.List {
			if strings.HasPrefix(c.Text, "//go:embed") {
				packageAndImports.WriteString(c.Text + "\n")
			}
		}
	}

	for _, decl := range f.Decls {
		if gen, ok := decl.(*ast.GenDecl); ok && gen.Tok == token.IMPORT {
			packageAndImports.WriteString(string(content[gen.Pos()-1 : gen.End()]) + "\n")
		}
	}

	varsAndStructs := ""
	functions := make(map[string]string)

	// Extract vars, structs, and functions
	for _, decl := range f.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			if d.Tok == token.VAR || d.Tok == token.TYPE {
				varsAndStructs += string(content[d.Pos()-1 : d.End()]) + "\n"
			}
		case *ast.FuncDecl:
			name := d.Name.Name
			functions[name] = string(content[d.Pos()-1 : d.End()]) + "\n"
		}
	}

	// Write .gopart files
	writeGopart(baseDir, "imports.gopart", packageAndImports.String())
	writeGopart(baseDir, "varsandstructs.gopart", varsAndStructs)
	for name, content := range functions {
		writeGopart(baseDir, name+".gopart", content)
	}

	fmt.Printf("Split %s into .gopart files in %s\n", filename, baseDir)
}

